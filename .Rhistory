plot(cumsum(pr_madrid$sdev^2/sum(pr_madrid$sdev^2)),main = "Autovalores")
grid()
# Asigno el numero componentes PCA
number_of_pca_components <- 6
# Asigno el número de vecinos que quiero encontrar
knn <- 5
# Me quedo con el número de coeficientes de PCA que he elegido en el apartamento de test
apart_pca <- apartment_transform[, 1:number_of_pca_components]
# Me quedo con el número de coeficientes del modelo
Amad <- pr_madrid$x[,1:number_of_pca_components]
# Calculo la distancia euclídea
dist <- rowSums((Amad - apart_pca)^2)
# Selecciono los 5 apartamentos que cumplen con la distancia
knn_tags <- order(dist,decreasing = F)[1:knn]
knn_tags
# Selecciono las filas del data frame que tienen esos apartamentos.
neigbourhood_near <- df_madrid_cluster[knn_tags,]
neigbourhood_near
# Asigno el numero componentes PCA
number_of_pca_components <- 6
# Asigno el número de vecinos que quiero encontrar
knn <- 5
# Me quedo con el número de coeficientes de PCA que he elegido en el apartamento de test
apart_pca <- apartment_transform[, 1:number_of_pca_components]
# Me quedo con el número de coeficientes del modelo
Amad <- pr_madrid$x[,1:number_of_pca_components]
# Calculo la distancia euclídea
dist <- rowSums((Amad - apart_pca)^2)
# Selecciono los 5 apartamentos que cumplen con la distancia
knn_tags <- order(dist,decreasing = F)[1:knn]
knn_tags
# Selecciono las filas del data frame que tienen esos apartamentos.
neigbourhood_near <- df_madrid_cluster[knn_tags,]
neigbourhood_near
View(df_madrid_cluster)
# Selecciono las filas del data frame que tienen esos apartamentos.
neigbourhood_near <- df_madrid_pca[knn_tags,]
neigbourhood_near
# Asigno el numero componentes PCA
number_of_pca_components <- 6
# Asigno el número de vecinos que quiero encontrar
knn <- 5
# Me quedo con el número de coeficientes de PCA que he elegido en el apartamento de test
apart_pca <- apartment_transform[, 1:number_of_pca_components]
# Me quedo con el número de coeficientes del modelo
Amad <- pr_madrid$x[,1:number_of_pca_components]
# Calculo la distancia euclídea
dist <- rowSums((Amad - apart_pca)^2)
# Selecciono los 5 apartamentos que cumplen con la distancia
knn_tags <- rownames(pca_matrix)[order(dist,decreasing = F) %in% c(1:knn)]
knn_tags
# Selecciono las filas del data frame que tienen esos apartamentos.
neigbourhood_near <- df_madrid_cluster[knn_tags,]
neigbourhood_near
# Selecciono los 5 apartamentos que cumplen con la distancia
knn_tags <- pca_matrix[order(dist,decreasing = F) %in% c(1:knn)]
# Selecciono las filas del data frame que tienen esos apartamentos.
neigbourhood_near <- df_madrid_cluster[knn_tags,]
# Asigno el numero componentes PCA
number_of_pca_components <- 6
# Asigno el número de vecinos que quiero encontrar
knn <- 5
# Me quedo con el número de coeficientes de PCA que he elegido en el apartamento de test
apart_pca <- apartment_transform[, 1:number_of_pca_components]
# Me quedo con el número de coeficientes del modelo
Amad <- pr_madrid$x[,1:number_of_pca_components]
# Calculo la distancia euclídea
dist <- rowSums((Amad - apart_pca)^2)
# Selecciono los 5 apartamentos que cumplen con la distancia
knn_tags <- pca_matrix[order(dist,decreasing = F) %in% c(1:knn)]
knn_tags
# Selecciono las filas del data frame que tienen esos apartamentos.
neigbourhood_near <- df_madrid_cluster[knn_tags,]
# Selecciono los 5 apartamentos que cumplen con la distancia
knn_tags <- df_madrid_pca[order(dist,decreasing = F) %in% c(1:knn)]
# Asigno el numero componentes PCA
number_of_pca_components <- 6
# Asigno el número de vecinos que quiero encontrar
knn <- 5
# Me quedo con el número de coeficientes de PCA que he elegido en el apartamento de test
apart_pca <- apartment_transform[, 1:number_of_pca_components]
# Me quedo con el número de coeficientes del modelo
Amad <- pr_madrid$x[,1:number_of_pca_components]
# Calculo la distancia euclídea
dist <- rowSums((Amad - apart_pca)^2)
# Selecciono los 5 apartamentos que cumplen con la distancia
knn_tags <- df_madrid_pca[order(dist,decreasing = F) %in% c(1:knn)]
rownames(
# Selecciono los 5 apartamentos que cumplen con la distancia
knn_tags <- rownames(pca_matrix[order(dist,decreasing = F) %in% c(1:knn)]
# Selecciono las filas del data frame que tienen esos apartamentos.
neigbourhood_near <- df_madrid_cluster[knn_tags,]
# Asigno el numero componentes PCA
number_of_pca_components <- 6
# Asigno el número de vecinos que quiero encontrar
knn <- 5
# Me quedo con el número de coeficientes de PCA que he elegido en el apartamento de test
apart_pca <- apartment_transform[, 1:number_of_pca_components]
# Me quedo con el número de coeficientes del modelo
Amad <- pr_madrid$x[,1:number_of_pca_components]
# Calculo la distancia euclídea
dist <- rowSums((Amad - apart_pca)^2)
# Selecciono los 5 apartamentos que cumplen con la distancia
knn_tags <- rownames(pca_matrix[order(dist,decreasing = F) %in% c(1:knn)]
knn_tags
# Selecciono los 5 apartamentos que cumplen con la distancia
knn_tags <- rownames(pca_matrix)[order(dist,decreasing = F) %in% c(1:knn)]
# Selecciono las filas del data frame que tienen esos apartamentos.
neigbourhood_near <- df_madrid_cluster[knn_tags,]
# Selecciono los 5 apartamentos que cumplen con la distancia
knn_tags <- rownames(pca_matrix)[order(dist,decreasing = F) %in% c(1:knn)]
knn_tags
# Selecciono las filas del data frame que tienen esos apartamentos.
neigbourhood_near <- df_madrid_cluster[knn_tags,]
# Asigno el numero componentes PCA
number_of_pca_components <- 6
# Asigno el número de vecinos que quiero encontrar
knn <- 5
# Me quedo con el número de coeficientes de PCA que he elegido en el apartamento de test
apart_pca <- apartment_transform[, 1:number_of_pca_components]
# Me quedo con el número de coeficientes del modelo
Amad <- pr_madrid$x[,1:number_of_pca_components]
# Calculo la distancia euclídea
dist <- rowSums((Amad - apart_pca)^2)
# Selecciono los 5 apartamentos que cumplen con la distancia
knn_tags <- rownames(pca_matrix)[order(dist,decreasing = F) %in% c(1:knn)]
knn_tags
knn_tags2 <- order(dist,decreasing = F)[1:knn]
knn_tags2
# Selecciono las filas del data frame que tienen esos apartamentos.
neigbourhood_near <- df_madrid_cluster[knn_tags,]
knn_tags
knn_tags
# Asigno el numero componentes PCA
number_of_pca_components <- 6
# Asigno el número de vecinos que quiero encontrar
knn <- 5
# Me quedo con el número de coeficientes de PCA que he elegido en el apartamento de test
apart_pca <- apartment_transform[, 1:number_of_pca_components]
# Me quedo con el número de coeficientes del modelo
Amad <- pr_madrid$x[,1:number_of_pca_components]
# Calculo la distancia euclídea
dist <- rowSums((Amad - apart_pca)^2)
# Selecciono los 5 apartamentos que cumplen con la distancia
knn_tags <- order(dist,decreasing = F)[1:knn]
knn_tags
# Selecciono las filas del data frame que tienen esos apartamentos.
neigbourhood_near <- df_madrid_cluster[knn_tags,]
neigbourhood_near
# Selecciono las filas del data frame que tienen esos apartamentos.
neigbourhood_near <- df_madrid_pca[knn_tags,]
neigbourhood_near
View(df_filter_madrid)
gc()
# Carga del dataset de airbnb
airbnb <- read.csv('airbnb-listings.csv',sep = ';')
options(repr.plot.height = 4,repr.plot.width = 6,repr.plot.res = 300)
library(dplyr)
# Selección de columnas
airbnb <- airbnb[,c('City','Room.Type','Neighbourhood','Accommodates','Bathrooms','Bedrooms','Beds','Price','Square.Feet','Guests.Included','Extra.People','Review.Scores.Rating','Latitude', 'Longitude')]
airbnb
# Creación del df de Madrid con Room Type = Entire home/apt
df_madrid <- airbnb |> filter(City == 'Madrid') |> filter(Room.Type == 'Entire home/apt')
# Convertimos los datos vacios de Neighbourhood en NA
df_madrid$Neighbourhood[which(df_madrid$Neighbourhood == '')] <- NA
# Elimimanos los datos que tienen NA en Neighbourhood y eliminamos las columnas City y Room Type
df_madrid <- df_madrid |> filter(!is.na(Neighbourhood)) |> select(-c('City','Room.Type'))
df_madrid
# Añadir columna de metros cuadrados convirtiendo la columna de pies cuadrados
rateToSquareMeter <- 0.092903
df_madrid$Square.Meters <- df_madrid$Square.Feet*rateToSquareMeter
df_madrid
# Porcentaje de apartamentos que no muestran metros cuadrados
totalApartment <- nrow(df_madrid)  # Total de apartamentos
naApartment <- sum(is.na(df_madrid$Square.Meters)) # Apartamentos que tienen Na como valor
porcentageNaApartament <- (naApartment/totalApartment)*100
paste('El porcentaje de apartamentos que no muestran los metros cuadrados es', round(porcentageNaApartament,2),'%') # Redondeo a 2 decimales
# Podemos aplicar un test binomial donde en probatility of sucess podemos ver el mismo porcentaje.
binom.test(naApartment,totalApartment)
# Porcentaje de apartamentos con 0 m2 de los apartamentos que tienen datos
apartmentSquareMeter <- df_madrid |> filter(!is.na(Square.Meters))
totalApartmentNo0 <- nrow(apartmentSquareMeter)  # Total de apartamentos de los que tenemos datos
ceroApartment <- sum(apartmentSquareMeter$Square.Meters == 0) # Apartamentos que tienen 0 como valor
porcentageCeroApartament <- (ceroApartment/totalApartmentNo0)*100
paste('El porcentaje de apartamentos con 0 metros cuadrados es', round(porcentageCeroApartament,2),'%') # Redondeo a dos decimales
#Comprobamos con un test binomial igual que en le punto anterior
binom.test(ceroApartment,totalApartmentNo0)
# Reemplazar los apartamentos con 0 m2 por NA
df_madrid$Square.Meters[which(df_madrid$Square.Meters == 0)] <- NA
df_madrid
# Pintamos el histagrama
library(ggplot2)
ggplot(data = df_madrid, aes(x = Square.Meters)) +
geom_histogram(fill = 'blue', color = 'black', bins = 20) +
xlab('Metros cuadrados') + ylab('Conteo') +
ggtitle('Histograma m2 apartamentos Madrid')
# Reemplazar los pisos con menos de 20 m2 por NA
df_madrid$Square.Meters[which(df_madrid$Square.Meters < 20)] <- NA
df_madrid
# Filtrar los barrios todos los pisos tienen Square.Meter
neighbourhood_with_metres <- unique(df_madrid$Neighbourhood[!is.na(df_madrid$Square.Meters)])
# Filtrar el dataset eliminando los pisos de los barrios sin metros cuadrados
df_filter_madrid <- df_madrid |> filter(Neighbourhood %in% neighbourhood_with_metres)
df_filter_madrid
# COMPROBAR SI SIGUE UNA DISTRIBUCIÓN NORMAL
shapiro.test(df_filter_madrid$Square.Meters)
# La hipótesis nula afirma que todos los Barrios tienen la misma media de metros cuadrados.
kruskalTest_madrid <- kruskal.test(Square.Meters ~ Neighbourhood, data = df_filter_madrid)
kruskalTest_madrid
tkyMadrid <- TukeyHSD(aov(Square.Meters ~ Neighbourhood, data = df_filter_madrid))
tkyMadrid
tkyMadrid.result <- data.frame(tkyMadrid$Neighbourhood)
cn <- sort(unique(df_filter_madrid$Neighbourhood))
resm <- matrix(NA, length(cn),length(cn))
rownames(resm) <- cn
colnames(resm) <- cn
resm[lower.tri(resm) ] <- round(tkyMadrid.result$p.adj,4)
resm[upper.tri(resm) ] <- t(resm)[upper.tri(resm)]
diag(resm) <- 1
library(ggplot2)
library(reshape2)
dfResm <- melt(resm)
ggplot(dfResm, aes(x = Var1, y = Var2, fill = value)) +
geom_tile(colour = "black") +
geom_text(aes(label = paste(round(value*100,0),"%")),size = 3) +
scale_fill_gradient(low = "white",high = "darkorange") +
ylab("Class") + xlab("Class") + theme_bw() +
theme(axis.text.x = element_text(angle = 90, hjust = 1),legend.position = "none")
library(dendextend)
distance <- as.dist(1 - abs(resm))
hcd <- hclust(distance, method = "complete")
madrid.dend <- as.dendrogram(hcd)
madrid.dend <- set(madrid.dend,"labels_cex", 0.5)
plot(color_branches(madrid.dend,h = 0.01),horiz = TRUE,cex = 0)
abline(v = 0.1,col = "red")
library(cluster)
clusters <- cutree_1h.dendrogram(madrid.dend,h = 0.1)
ss <- silhouette(clusters, distance)
plot(ss,col = 1:max(clusters),border = NA)
df_cluster <- data.frame(clusters) # Convierte clusters a data frame
df_madrid_cluster <- merge(df_filter_madrid, df_cluster) # Lo uno con el df_filter_madrid
df_madrid_cluster <- df_madrid_cluster |> rename(neighb_id = clusters) # Renombro la columna clusters a neighb_id
df_madrid_cluster$neighb_id <- as.factor(df_madrid_cluster$neighb_id) # La paso a factor
summary(df_madrid_cluster)
set.seed(12345)
# Elimino los NA en la columan de Review.Scores.Rating que luego me están danda NA en el MSE
# df_madrid_cluster <- df_madrid_cluster |> na.omit(df_madrid_cluster$Review.Scores.Rating)
# Selecciono los idx de forma aleatoaria, pongo una semilla para evitar cada vez tener unos resultados.
idx <- sample(1:nrow(df_madrid_cluster),nrow(df_madrid_cluster)*0.7)
# Selecciono los data frames con esos indices
df_madrid.train <- df_madrid_cluster[idx,] # DATA FRAME DE TRAINING
df_madrid.test <- df_madrid_cluster[-idx,] # DATA FRAME DE TESTING
df_madrid_cluster
df_madrid.test
df_madrid.train
# USO UNA REGRESION LINEAL  PARA MI MODELO
modelMadrid <- lm(Square.Meters~Accommodates+Bathrooms+Bedrooms+Beds+Price+Review.Scores.Rating+neighb_id,df_madrid.train)
summary(modelMadrid)
confint(modelMadrid)
# Añado a mis data frames de training y testing una columna con la predicción del modelo
df_madrid.train$sqm_est <- predict(modelMadrid, df_madrid.train)
df_madrid.test$sqm_est <- predict(modelMadrid, df_madrid.test)
# Comparativa de los errores cuadráticos medios y R2 en training y testing
caret::postResample(pred = predict(modelMadrid, df_madrid.train), obs = df_madrid.train$Square.Meters)
caret::postResample(pred = predict(modelMadrid, df_madrid.test), obs = df_madrid.test$Square.Meters)
# Gráfica para ver la distancia de Cook
plot(cooks.distance(modelMadrid))
# Pintamos un gráfico de puntos para ver según los metros cuadrados el residuo entre el valor real y el estamido en testing.
ggplot(df_madrid.train, aes(x = Square.Meters, y = Square.Meters - sqm_est)) + geom_point()
# Comprobamos en un gráfico si lso residuos siguen una distribución normal
qqnorm(df_madrid.train$Square.Meters - df_madrid.train$sqm_est)
qqline(df_madrid.train$Square.Meters - df_madrid.train$sqm_est, col = 'orange', lwd = 2)
# Definir data frame con los valores y que está en uno de los barrios categorizados como 2
data = data.frame(Accommodates = 6,
Bathrooms = 1,
Bedrooms = 3,
Price = 80,
Beds = 3,
Review.Scores.Rating = 80,
neighb_id = '2')
estimacion_sqm <- predict(modelMadrid, data)
# Imprimir los metros cuadrados predichos
paste('El aparatamento tiene: ', round(estimacion_sqm,2), ' m2')
paste('Los m2 aumentan por habitación extra: ', round(modelMadrid$coefficients[4], 2), ' m2')
# Encontrar las filas con valores faltantes en Square.Meters
miss_index <- which(is.na(df_madrid_cluster$Square.Meters))
# Crear un dataframe temporal con las variables predictoras para las filas con valores faltantes
data_new <- data.frame(
Accommodates = df_madrid_cluster$Accommodates[miss_index],
Bathrooms = df_madrid_cluster$Bathrooms[miss_index],
Bedrooms = df_madrid_cluster$Bedrooms[miss_index],
Price = df_madrid_cluster$Price[miss_index],
Beds = df_madrid_cluster$Beds[miss_index],
Review.Scores.Rating = df_madrid_cluster$Review.Scores.Rating[miss_index],
neighb_id = df_madrid_cluster$neighb_id[miss_index]
)
# Predice los valores faltantes utilizando el modelo
predict_values <- predict(modelMadrid, data_new)
# Asigna los valores predichos a las filas con valores faltantes en Square.Meters
df_madrid_cluster$Square.Meters[miss_index] <- predict_values
df_madrid_cluster
# Seleccion las columnas númericas del data frame
df_madrid_pca <- df_madrid_cluster |> select(-c('Neighbourhood','Square.Feet','neighb_id'))
# Convierto el data frame en matriz
pca_matrix <- as.matrix(df_madrid_pca)
# Creo un data frame con el apartamento que quiero buscar los más similares
new_apartment <- data.frame(Accommodates = 2, Bathrooms = 1.0, Bedrooms = 2, Beds = 4,Price = 90, Guests.Included = 2, Extra.People = 2, Review.Scores.Rating = 87, Latitude = 40.000000, Longitude = -3.00000, Square.Meters = 66.08)
# Aplico un  modelo PCA
pr_madrid <- prcomp(pca_matrix,center = TRUE, scale. = TRUE)
gc()
# Carga del dataset de airbnb
airbnb <- read.csv('airbnb-listings.csv',sep = ';')
options(repr.plot.height = 4,repr.plot.width = 6,repr.plot.res = 300)
library(dplyr)
# Selección de columnas
airbnb <- airbnb[,c('City','Room.Type','Neighbourhood','Accommodates','Bathrooms','Bedrooms','Beds','Price','Square.Feet','Guests.Included','Extra.People','Review.Scores.Rating','Latitude', 'Longitude')]
airbnb
# Creación del df de Madrid con Room Type = Entire home/apt
df_madrid <- airbnb |> filter(City == 'Madrid') |> filter(Room.Type == 'Entire home/apt')
# Convertimos los datos vacios de Neighbourhood en NA
df_madrid$Neighbourhood[which(df_madrid$Neighbourhood == '')] <- NA
# Elimimanos los datos que tienen NA en Neighbourhood y eliminamos las columnas City y Room Type
df_madrid <- df_madrid |> filter(!is.na(Neighbourhood)) |> select(-c('City','Room.Type'))
df_madrid
# Añadir columna de metros cuadrados convirtiendo la columna de pies cuadrados
rateToSquareMeter <- 0.092903
df_madrid$Square.Meters <- df_madrid$Square.Feet*rateToSquareMeter
df_madrid
# Porcentaje de apartamentos que no muestran metros cuadrados
totalApartment <- nrow(df_madrid)  # Total de apartamentos
naApartment <- sum(is.na(df_madrid$Square.Meters)) # Apartamentos que tienen Na como valor
porcentageNaApartament <- (naApartment/totalApartment)*100
paste('El porcentaje de apartamentos que no muestran los metros cuadrados es', round(porcentageNaApartament,2),'%') # Redondeo a 2 decimales
# Podemos aplicar un test binomial donde en probatility of sucess podemos ver el mismo porcentaje.
binom.test(naApartment,totalApartment)
# Porcentaje de apartamentos con 0 m2 de los apartamentos que tienen datos
apartmentSquareMeter <- df_madrid |> filter(!is.na(Square.Meters))
totalApartmentNo0 <- nrow(apartmentSquareMeter)  # Total de apartamentos de los que tenemos datos
ceroApartment <- sum(apartmentSquareMeter$Square.Meters == 0) # Apartamentos que tienen 0 como valor
porcentageCeroApartament <- (ceroApartment/totalApartmentNo0)*100
paste('El porcentaje de apartamentos con 0 metros cuadrados es', round(porcentageCeroApartament,2),'%') # Redondeo a dos decimales
#Comprobamos con un test binomial igual que en le punto anterior
binom.test(ceroApartment,totalApartmentNo0)
# Reemplazar los apartamentos con 0 m2 por NA
df_madrid$Square.Meters[which(df_madrid$Square.Meters == 0)] <- NA
df_madrid
# Pintamos el histagrama
library(ggplot2)
ggplot(data = df_madrid, aes(x = Square.Meters)) +
geom_histogram(fill = 'blue', color = 'black', bins = 20) +
xlab('Metros cuadrados') + ylab('Conteo') +
ggtitle('Histograma m2 apartamentos Madrid')
# Reemplazar los pisos con menos de 20 m2 por NA
df_madrid$Square.Meters[which(df_madrid$Square.Meters < 20)] <- NA
df_madrid
# COMPROBAR SI SIGUE UNA DISTRIBUCIÓN NORMAL
shapiro.test(df_filter_madrid$Square.Meters)
# Filtrar los barrios todos los pisos tienen Square.Meter
neighbourhood_with_metres <- unique(df_madrid$Neighbourhood[!is.na(df_madrid$Square.Meters)])
# Filtrar el dataset eliminando los pisos de los barrios sin metros cuadrados
df_filter_madrid <- df_madrid |> filter(Neighbourhood %in% neighbourhood_with_metres)
df_filter_madrid
# COMPROBAR SI SIGUE UNA DISTRIBUCIÓN NORMAL
shapiro.test(df_filter_madrid$Square.Meters)
# La hipótesis nula afirma que todos los Barrios tienen la misma media de metros cuadrados.
kruskalTest_madrid <- kruskal.test(Square.Meters ~ Neighbourhood, data = df_filter_madrid)
kruskalTest_madrid
tkyMadrid <- TukeyHSD(aov(Square.Meters ~ Neighbourhood, data = df_filter_madrid))
tkyMadrid
tkyMadrid.result <- data.frame(tkyMadrid$Neighbourhood)
cn <- sort(unique(df_filter_madrid$Neighbourhood))
resm <- matrix(NA, length(cn),length(cn))
rownames(resm) <- cn
colnames(resm) <- cn
resm[lower.tri(resm) ] <- round(tkyMadrid.result$p.adj,4)
resm[upper.tri(resm) ] <- t(resm)[upper.tri(resm)]
diag(resm) <- 1
library(ggplot2)
library(reshape2)
dfResm <- melt(resm)
ggplot(dfResm, aes(x = Var1, y = Var2, fill = value)) +
geom_tile(colour = "black") +
geom_text(aes(label = paste(round(value*100,0),"%")),size = 3) +
scale_fill_gradient(low = "white",high = "darkorange") +
ylab("Class") + xlab("Class") + theme_bw() +
theme(axis.text.x = element_text(angle = 90, hjust = 1),legend.position = "none")
library(dendextend)
distance <- as.dist(1 - abs(resm))
hcd <- hclust(distance, method = "complete")
madrid.dend <- as.dendrogram(hcd)
madrid.dend <- set(madrid.dend,"labels_cex", 0.5)
plot(color_branches(madrid.dend,h = 0.01),horiz = TRUE,cex = 0)
abline(v = 0.1,col = "red")
library(cluster)
clusters <- cutree_1h.dendrogram(madrid.dend,h = 0.1)
ss <- silhouette(clusters, distance)
plot(ss,col = 1:max(clusters),border = NA)
clusters
df_cluster <- data.frame(clusters) # Convierte clusters a data frame
df_madrid_cluster <- merge(df_filter_madrid, df_cluster) # Lo uno con el df_filter_madrid
df_madrid_cluster <- df_madrid_cluster |> rename(neighb_id = clusters) # Renombro la columna clusters a neighb_id
df_madrid_cluster$neighb_id <- as.factor(df_madrid_cluster$neighb_id) # La paso a factor
summary(df_madrid_cluster)
df_cluster
# Carga del dataset de airbnb
airbnb <- read.csv('airbnb-listings.csv',sep = ';')
options(repr.plot.height = 4,repr.plot.width = 6,repr.plot.res = 300)
library(dplyr)
# Selección de columnas
airbnb <- airbnb[,c('City','Room.Type','Neighbourhood','Accommodates','Bathrooms','Bedrooms','Beds','Price','Square.Feet','Guests.Included','Extra.People','Review.Scores.Rating','Latitude', 'Longitude')]
airbnb
# Creación del df de Madrid con Room Type = Entire home/apt
df_madrid <- airbnb |> filter(City == 'Madrid') |> filter(Room.Type == 'Entire home/apt')
# Convertimos los datos vacios de Neighbourhood en NA
df_madrid$Neighbourhood[which(df_madrid$Neighbourhood == '')] <- NA
# Elimimanos los datos que tienen NA en Neighbourhood y eliminamos las columnas City y Room Type
df_madrid <- df_madrid |> filter(!is.na(Neighbourhood)) |> select(-c('City','Room.Type'))
df_madrid
# Añadir columna de metros cuadrados convirtiendo la columna de pies cuadrados
rateToSquareMeter <- 0.092903
df_madrid$Square.Meters <- df_madrid$Square.Feet*rateToSquareMeter
df_madrid
# Porcentaje de apartamentos que no muestran metros cuadrados
totalApartment <- nrow(df_madrid)  # Total de apartamentos
naApartment <- sum(is.na(df_madrid$Square.Meters)) # Apartamentos que tienen Na como valor
porcentageNaApartament <- (naApartment/totalApartment)*100
paste('El porcentaje de apartamentos que no muestran los metros cuadrados es', round(porcentageNaApartament,2),'%') # Redondeo a 2 decimales
# Podemos aplicar un test binomial donde en probatility of sucess podemos ver el mismo porcentaje.
binom.test(naApartment,totalApartment)
# Porcentaje de apartamentos con 0 m2 de los apartamentos que tienen datos
apartmentSquareMeter <- df_madrid |> filter(!is.na(Square.Meters))
totalApartmentNo0 <- nrow(apartmentSquareMeter)  # Total de apartamentos de los que tenemos datos
ceroApartment <- sum(apartmentSquareMeter$Square.Meters == 0) # Apartamentos que tienen 0 como valor
porcentageCeroApartament <- (ceroApartment/totalApartmentNo0)*100
paste('El porcentaje de apartamentos con 0 metros cuadrados es', round(porcentageCeroApartament,2),'%') # Redondeo a dos decimales
#Comprobamos con un test binomial igual que en le punto anterior
binom.test(ceroApartment,totalApartmentNo0)
# Reemplazar los apartamentos con 0 m2 por NA
df_madrid$Square.Meters[which(df_madrid$Square.Meters == 0)] <- NA
df_madrid
# Pintamos el histagrama
library(ggplot2)
ggplot(data = df_madrid, aes(x = Square.Meters)) +
geom_histogram(fill = 'blue', color = 'black', bins = 20) +
xlab('Metros cuadrados') + ylab('Conteo') +
ggtitle('Histograma m2 apartamentos Madrid')
# Reemplazar los pisos con menos de 20 m2 por NA
df_madrid$Square.Meters[which(df_madrid$Square.Meters < 20)] <- NA
df_madrid
# Filtrar los barrios todos los pisos tienen Square.Meter
neighbourhood_with_metres <- unique(df_madrid$Neighbourhood[!is.na(df_madrid$Square.Meters)])
# Filtrar el dataset eliminando los pisos de los barrios sin metros cuadrados
df_filter_madrid <- df_madrid |> filter(Neighbourhood %in% neighbourhood_with_metres)
df_filter_madrid
# COMPROBAR SI SIGUE UNA DISTRIBUCIÓN NORMAL
shapiro.test(df_filter_madrid$Square.Meters)
# La hipótesis nula afirma que todos los Barrios tienen la misma media de metros cuadrados.
kruskalTest_madrid <- kruskal.test(Square.Meters ~ Neighbourhood, data = df_filter_madrid)
kruskalTest_madrid
tkyMadrid <- TukeyHSD(aov(Square.Meters ~ Neighbourhood, data = df_filter_madrid))
tkyMadrid
tkyMadrid.result <- data.frame(tkyMadrid$Neighbourhood)
cn <- sort(unique(df_filter_madrid$Neighbourhood))
resm <- matrix(NA, length(cn),length(cn))
rownames(resm) <- cn
colnames(resm) <- cn
resm[lower.tri(resm) ] <- round(tkyMadrid.result$p.adj,4)
resm[upper.tri(resm) ] <- t(resm)[upper.tri(resm)]
diag(resm) <- 1
library(ggplot2)
library(reshape2)
dfResm <- melt(resm)
ggplot(dfResm, aes(x = Var1, y = Var2, fill = value)) +
geom_tile(colour = "black") +
geom_text(aes(label = paste(round(value*100,0),"%")),size = 3) +
scale_fill_gradient(low = "white",high = "darkorange") +
ylab("Class") + xlab("Class") + theme_bw() +
theme(axis.text.x = element_text(angle = 90, hjust = 1),legend.position = "none")
library(dendextend)
distance <- as.dist(1 - abs(resm))
hcd <- hclust(distance, method = "complete")
madrid.dend <- as.dendrogram(hcd)
madrid.dend <- set(madrid.dend,"labels_cex", 0.5)
plot(color_branches(madrid.dend,h = 0.01),horiz = TRUE,cex = 0)
abline(v = 0.1,col = "red")
library(cluster)
clusters <- cutree_1h.dendrogram(madrid.dend,h = 0.1)
ss <- silhouette(clusters, distance)
plot(ss,col = 1:max(clusters),border = NA)
df_cluster <- data.frame(clusters) # Convierte clusters a data frame
df_madrid_cluster <- left_join(df_filter_madrid, df_cluster, by = 'Neighbourhood') # Lo uno con el df_filter_madrid
df_cluster
rownames(df_cluster)
colnames(df_cluster)
df_filter_madrid
df_cluster
df_cluster <- data.frame(clusters) # Convierte clusters a data frame
# Obtener los nombres de los barrios del DataFrame original
rownames(df_cluster)<- df_cluster$Neighbourhood
df_cluster
df_madrid_cluster <- left_join(df_filter_madrid, df_cluster, by = 'Neighbourhood') # Lo uno con el df_filter_madrid
df_cluster$Neighbourhood<-NULL
df_cluster <- data.frame(clusters) # Convierte clusters a data frame
# Obtener los nombres de los barrios del DataFrame original
rownames(df_cluster)<- df_cluster$Neighbourhood
df_cluster$Neighbourhood<-NULL
df_madrid_cluster <- left_join(df_filter_madrid, df_cluster, by = 'Neighbourhood') # Lo uno con el df_filter_madrid
df_madrid_cluster <- merge(df_filter_madrid, df_cluster, by = 'Neighbourhood') # Lo uno con el df_filter_madrid
df_cluster$Neighb_id<-NULL
df_madrid_cluster <- merge(df_filter_madrid, df_cluster, by = 'Neighbourhood') # Lo uno con el df_filter_madrid
df_madrid_cluster <- merge(df_filter_madrid, df_cluster, by = 'Neighbourhood') # Lo uno con el df_filter_madrid
df_madrid_cluster <- merge(df_filter_madrid, df_cluster) # Lo uno con el df_filter_madrid
